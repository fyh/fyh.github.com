---
layout: post
date: 2018-01-15 23:25:13 +0800
title: TCC模型：业务事务，补偿和TCC
nocomments: false
---

[1]: Business Transactions, Compensation and the Try-
Cancel/Confirm (TCC) Approach for Web Services

未完待补充。。。

这个系列博客是我个人的TCC学习笔记，内容大致会包括TCC及各种模型的理解、遇到的问题和找到的办法。写得不好的地方或者写得好的地方，都欢迎交流。

[1][1] 是对TCC的最基本的介绍。有两个核心的概念：

1. 事务是一组关联的操作，特点是执行后也可能被全部取消掉
2. 业务事务，一个比较“长”的事务，特点是整个事务的耗时超出每个独立子事务耗时的几个数量级

作者举了个简单的例子：假设一个人要从A地飞往B地，但是没有A直接到B的机票，需要先从A到C，然后再从C到B。然后A到C的机票和C到B的机票分别是通过两个不同的系统来预订。如果两个都预定成功了，那没问题。但是如果其中一个订成功，但是另一个订失败了，成功的那个应该取消掉（否则浪费钱啊）。所以总结来说，是要完成一个跨系统的预订机票的事务。

显然，使用ACID事务可以做到分布式事务，并且使用ACID来做，和本地事务区别并不大：依次执行（但不提交）各个本地事务，如果遇到失败了，就让已经执行都回滚掉。

这个方法其实挺完美的，不过作者认为其缺点是ACID事务都要锁资源，导致被锁的资源不可用。这对长事务来说不可接受，因为会导致长时间的不可用。这点是可以理解的，比如MySQL的ACID，更新一条记录时需要加写锁，会阻塞其他的读和写操作。

作者针对ACID的缺点，提出了补偿的方案：让各个独立的事务独自提交，如果遇到某个失败了，通过业务层面执行一个回滚即Cancel的逻辑，从而补偿了已经提交的事务。这个方案的好处是，显著降低了数据库锁的时长。

作者认为，具体业务的取消操作大致分为两类：

第一类是完美补偿，例如股票交易，买入和卖出是两个互补的操作，可以完美地进行补偿，没有留下任何业务负担，服务的提供者是无状态的。

第二类是不完美补偿，例如上面例子中的机票预订，取消已经预订的机票并不会让订单消失，结果是让订单走到了**一个取消的状态**，即补偿是同一个业务事务的第二个阶段。TCC的Try是第一个阶段，如果都成功执行则Confirm，走到第二个阶段（更新状态）；否则Cancel，也是走到另一个第二阶段（更新状态），只不过和Confirm的状态不同。具体实施时，第一个阶段中，可以把已经成功预订的机票的状态看作PENDING，如果所有的都PENDING，Confirm操作让它们都变成COMPLETE，否则，Cancel操作让它们都变为CANCELLED。

作者还对上述两种场景做了架构建议：

1. 对第一种场景，可以简单地用工作流引擎来建模，每个操作不管是买入还是卖出都是其中的一步骤
2. 对第二种场景，PENDING的状态其实也预占了资源，所以需要通过timeout来自动进行取消操作。

问题：

1. MySQL在更新一条记录时，会持有X锁，更新语句执行后事务提交前，其他的查询真的会被阻塞吗？（看起来不会），如何做到的？和上面的ACID锁资源导致不可用的说法是否冲突？
2. 接问题1，MySQL的事务隔离，是不是很大程度上缓解ACID锁导致不可用的方法？
3. 补偿失败了怎么处理？（作者问题1）
4. 如何处理通信失败，以及重试而不重复提交？（作者问题2）